name: üîí Auditor√≠a Profesional de Dependencias y Vulnerabilidades

on:
  workflow_dispatch:
    inputs:
      include_dev_dependencies:
        description: 'Incluir dependencias de desarrollo'
        required: false
        default: true
        type: boolean
      report_format:
        description: 'Formato del reporte'
        required: false
        default: 'all'
        type: choice
        options:
        - all
        - pdf
        - json
  push:
    branches:
      - '**'
  pull_request:
    branches:
      - '**'
  schedule:
    - cron: '0 2 * * 1' # Lunes a las 2 AM

env:
  NODE_VERSION: '20'
  AUDIT_LEVEL: 'info'

jobs:
  security-audit:
    name: üõ°Ô∏è Auditor√≠a de Seguridad
    runs-on: ubuntu-latest
    timeout-minutes: 15

    permissions:
      contents: read
      security-events: write
      pull-requests: write

    outputs:
      total-vulnerabilities: ${{ steps.audit-summary.outputs.total-vulnerabilities }}
      critical-high-count: ${{ steps.audit-summary.outputs.critical-high-count }}
      report-generated: ${{ steps.audit-summary.outputs.report-generated }}

    steps:
      - name: üì• Checkout del c√≥digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üü¢ Configurar Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: üì¶ Instalar dependencias
        run: |
          npm ci --prefer-offline --no-audit --no-fund
          echo "‚úÖ Dependencias instaladas correctamente"

      - name: üìã Inventario de dependencias
        run: |
          echo "üìä Generando inventario completo de dependencias..."
          npm list --all --json > dependency-tree.json
          npm list --depth=0 --json > direct-dependencies.json
          
          # Estad√≠sticas b√°sicas
          TOTAL_DEPS=$(jq -r '.dependencies | keys | length' direct-dependencies.json 2>/dev/null || echo "0")
          echo "üì¶ Total dependencias directas: $TOTAL_DEPS"
          echo "TOTAL_DEPENDENCIES=$TOTAL_DEPS" >> $GITHUB_ENV

      - name: üîç Ejecutar auditor√≠a de seguridad
        id: security-audit
        run: |
          echo "üîç Iniciando auditor√≠a de seguridad..."
          
          # Ejecutar audit y capturar resultado
          set +e
          npm audit --json > audit-raw.json
          AUDIT_EXIT_CODE=$?
          set -e
          
          echo "AUDIT_EXIT_CODE=$AUDIT_EXIT_CODE" >> $GITHUB_ENV
          
          if [ $AUDIT_EXIT_CODE -eq 0 ]; then
            echo "‚úÖ No se encontraron vulnerabilidades"
          else
            echo "‚ö†Ô∏è Se encontraron vulnerabilidades (c√≥digo: $AUDIT_EXIT_CODE)"
          fi

      - name: üßÆ Procesar resultados de auditor√≠a
        id: audit-summary
        run: |
          node << 'EOF'
          const fs = require('fs');
          const https = require('https');
          const { execSync } = require('child_process');

          class DependencyAuditor {
            constructor() {
              this.auditData = {};
              this.dependencyTree = {};
              this.npmCache = new Map();
              this.reportData = [];
            }

            async initialize() {
              try {
                console.log('üìä Inicializando auditor de dependencias...');
                
                // Cargar datos de auditor√≠a
                const auditRaw = fs.readFileSync('audit-raw.json', 'utf8');
                this.auditData = JSON.parse(auditRaw);
                
                // Cargar √°rbol de dependencias
                const treeRaw = fs.readFileSync('dependency-tree.json', 'utf8');
                this.dependencyTree = JSON.parse(treeRaw);
                
                console.log('‚úÖ Datos cargados correctamente');
              } catch (error) {
                console.error('‚ùå Error inicializando:', error.message);
                throw error;
              }
            }

            extractAllDependencies() {
              const allDeps = new Map();
              
              const traverse = (deps, isDevDep = false) => {
                if (!deps) return;
                
                for (const [name, info] of Object.entries(deps)) {
                  if (!allDeps.has(name)) {
                    allDeps.set(name, {
                      version: info.version || 'unknown',
                      isDev: isDevDep,
                      path: info.path || name
                    });
                  }
                  traverse(info.dependencies, isDevDep);
                }
              };

              traverse(this.dependencyTree.dependencies, false);
              traverse(this.dependencyTree.devDependencies, true);
              
              return allDeps;
            }

            async fetchNpmMetadata(packageName) {
              if (this.npmCache.has(packageName)) {
                return this.npmCache.get(packageName);
              }

              return new Promise((resolve) => {
                const options = {
                  hostname: 'registry.npmjs.org',
                  path: `/${encodeURIComponent(packageName)}`,
                  method: 'GET',
                  timeout: 5000
                };

                const req = https.request(options, (res) => {
                  let data = '';
                  
                  res.on('data', chunk => data += chunk);
                  res.on('end', () => {
                    try {
                      const pkg = JSON.parse(data);
                      const metadata = {
                        latestVersion: pkg['dist-tags']?.latest || null,
                        description: pkg.description || '',
                        homepage: pkg.homepage || '',
                        repository: pkg.repository?.url || '',
                        license: pkg.license || 'Unknown',
                        maintainers: pkg.maintainers?.length || 0,
                        lastPublish: this.getLastPublishDate(pkg),
                        weeklyDownloads: null // Se podr√≠a obtener de otra API
                      };
                      
                      this.npmCache.set(packageName, metadata);
                      resolve(metadata);
                    } catch (error) {
                      console.warn(`‚ö†Ô∏è Error parsing metadata for ${packageName}`);
                      resolve(this.getDefaultMetadata());
                    }
                  });
                });

                req.on('error', () => {
                  console.warn(`‚ö†Ô∏è Error fetching metadata for ${packageName}`);
                  resolve(this.getDefaultMetadata());
                });

                req.on('timeout', () => {
                  req.destroy();
                  resolve(this.getDefaultMetadata());
                });

                req.end();
              });
            }

            getLastPublishDate(pkg) {
              if (!pkg.time) return null;
              
              const versions = Object.keys(pkg.versions || {});
              if (versions.length === 0) return null;
              
              const latestVersion = pkg['dist-tags']?.latest;
              return pkg.time[latestVersion] || Object.values(pkg.time).sort().pop();
            }

            getDefaultMetadata() {
              return {
                latestVersion: null,
                description: '',
                homepage: '',
                repository: '',
                license: 'Unknown',
                maintainers: 0,
                lastPublish: null,
                weeklyDownloads: null
              };
            }

            analyzeVulnerabilities() {
              const vulnMap = new Map();
              
              if (this.auditData.vulnerabilities) {
                for (const [pkgName, vuln] of Object.entries(this.auditData.vulnerabilities)) {
                  const severity = vuln.severity || 'unknown';
                  const count = Array.isArray(vuln.via) ? vuln.via.length : 1;
                  
                  vulnMap.set(pkgName, {
                    severity,
                    count,
                    title: vuln.title || 'Vulnerabilidad sin t√≠tulo',
                    range: vuln.range || '*',
                    nodes: vuln.nodes || [],
                    fixAvailable: vuln.fixAvailable || false
                  });
                }
              }
              
              return vulnMap;
            }

            getRiskLevel(severity, lastPublish) {
              if (severity === 'critical') return 'CR√çTICO';
              if (severity === 'high') return 'ALTO';
              if (severity === 'moderate') return 'MEDIO';
              if (severity === 'low') return 'BAJO';
              
              // Evaluar riesgo por antiguedad
              if (lastPublish) {
                const daysSinceUpdate = (Date.now() - new Date(lastPublish)) / (1000 * 60 * 60 * 24);
                if (daysSinceUpdate > 730) return 'OBSOLETO'; // 2 a√±os
                if (daysSinceUpdate > 365) return 'ANTIGUO'; // 1 a√±o
              }
              
              return 'SEGURO';
            }

            getRecommendation(vulnerability, metadata, currentVersion) {
              if (!vulnerability) {
                if (metadata.latestVersion && currentVersion !== metadata.latestVersion) {
                  return `Actualizar a ${metadata.latestVersion}`;
                }
                return 'Mantener versi√≥n actual';
              }

              const { severity, fixAvailable } = vulnerability;
              
              if (severity === 'critical') {
                return fixAvailable ? 'üö® ACTUALIZAR INMEDIATAMENTE' : 'üö® REEMPLAZAR PAQUETE';
              }
              
              if (severity === 'high') {
                return fixAvailable ? '‚ö° Actualizar con prioridad alta' : '‚ö†Ô∏è Buscar alternativas';
              }
              
              if (severity === 'moderate') {
                return fixAvailable ? 'üìÖ Actualizar pr√≥ximamente' : 'üîç Revisar impacto';
              }
              
              return fixAvailable ? 'üìù Considerar actualizaci√≥n' : 'üëÄ Monitorear';
            }

            async generateReport() {
              console.log('üìä Generando reporte detallado...');
              
              const allDeps = this.extractAllDependencies();
              const vulnerabilities = this.analyzeVulnerabilities();
              
              console.log(`üì¶ Analizando ${allDeps.size} dependencias...`);
              
              let processed = 0;
              for (const [name, depInfo] of allDeps) {
                const metadata = await this.fetchNpmMetadata(name);
                const vulnerability = vulnerabilities.get(name);
                
                const riskLevel = this.getRiskLevel(
                  vulnerability?.severity, 
                  metadata.lastPublish
                );
                
                this.reportData.push({
                  name,
                  currentVersion: depInfo.version,
                  latestVersion: metadata.latestVersion || 'N/A',
                  description: metadata.description.substring(0, 100),
                  license: metadata.license,
                  lastPublish: metadata.lastPublish ? 
                    new Date(metadata.lastPublish).toISOString().split('T')[0] : 'N/A',
                  daysSinceUpdate: metadata.lastPublish ? 
                    Math.floor((Date.now() - new Date(metadata.lastPublish)) / (1000 * 60 * 60 * 24)) : null,
                  severity: vulnerability?.severity || 'none',
                  vulnerabilityCount: vulnerability?.count || 0,
                  vulnerabilityTitle: vulnerability?.title || '',
                  riskLevel,
                  recommendation: this.getRecommendation(vulnerability, metadata, depInfo.version),
                  isDev: depInfo.isDev,
                  maintainers: metadata.maintainers,
                  homepage: metadata.homepage,
                  repository: metadata.repository
                });
                
                processed++;
                if (processed % 10 === 0) {
                  console.log(`üìä Procesadas ${processed}/${allDeps.size} dependencias...`);
                }
              }
              
              console.log('‚úÖ Reporte generado completamente');
            }

            generateSummary() {
              const summary = {
                date: new Date().toISOString(),
                totalDependencies: this.reportData.length,
                productionDependencies: this.reportData.filter(d => !d.isDev).length,
                devDependencies: this.reportData.filter(d => d.isDev).length,
                vulnerabilityCounts: {
                  critical: this.reportData.filter(d => d.severity === 'critical').length,
                  high: this.reportData.filter(d => d.severity === 'high').length,
                  moderate: this.reportData.filter(d => d.severity === 'moderate').length,
                  low: this.reportData.filter(d => d.severity === 'low').length,
                  none: this.reportData.filter(d => d.severity === 'none').length
                },
                riskDistribution: {},
                topVulnerable: this.reportData
                  .filter(d => d.vulnerabilityCount > 0)
                  .sort((a, b) => b.vulnerabilityCount - a.vulnerabilityCount)
                  .slice(0, 10),
                outdatedPackages: this.reportData
                  .filter(d => d.daysSinceUpdate && d.daysSinceUpdate > 365)
                  .sort((a, b) => b.daysSinceUpdate - a.daysSinceUpdate)
                  .slice(0, 10),
                updateCandidates: this.reportData
                  .filter(d => d.latestVersion !== 'N/A' && d.currentVersion !== d.latestVersion)
                  .slice(0, 20)
              };

              // Calcular distribuci√≥n de riesgo
              ['CR√çTICO', 'ALTO', 'MEDIO', 'BAJO', 'SEGURO', 'OBSOLETO', 'ANTIGUO'].forEach(risk => {
                summary.riskDistribution[risk] = this.reportData.filter(d => d.riskLevel === risk).length;
              });

              return summary;
            }

            saveReports() {
              const summary = this.generateSummary();
              
              // Guardar datos completos
              fs.writeFileSync('audit-complete-report.json', JSON.stringify({
                summary,
                dependencies: this.reportData
              }, null, 2));

              // Guardar resumen para GitHub Actions
              fs.writeFileSync('audit-summary.json', JSON.stringify(summary, null, 2));

              // Resumen en texto
              let textReport = `üîí REPORTE DE AUDITOR√çA DE SEGURIDAD\n`;
              textReport += `üìÖ Fecha: ${new Date().toLocaleString()}\n\n`;
              textReport += `üìä RESUMEN EJECUTIVO:\n`;
              textReport += `‚îú‚îÄ Total dependencias: ${summary.totalDependencies}\n`;
              textReport += `‚îú‚îÄ Producci√≥n: ${summary.productionDependencies}\n`;
              textReport += `‚îú‚îÄ Desarrollo: ${summary.devDependencies}\n`;
              textReport += `‚îî‚îÄ Vulnerabilidades cr√≠ticas/altas: ${summary.vulnerabilityCounts.critical + summary.vulnerabilityCounts.high}\n\n`;

              if (summary.topVulnerable.length > 0) {
                textReport += `üö® TOP VULNERABILIDADES:\n`;
                summary.topVulnerable.slice(0, 5).forEach((pkg, i) => {
                  textReport += `${i + 1}. ${pkg.name}@${pkg.currentVersion} - ${pkg.vulnerabilityCount} vulnerabilidades (${pkg.severity.toUpperCase()})\n`;
                });
              } else {
                textReport += `‚úÖ No se encontraron vulnerabilidades cr√≠ticas\n`;
              }

              fs.writeFileSync('audit-summary.txt', textReport);

              return summary;
            }
          }

          // Ejecutar auditor√≠a
          (async () => {
            try {
              const auditor = new DependencyAuditor();
              await auditor.initialize();
              await auditor.generateReport();
              const summary = auditor.saveReports();

              // Configurar outputs para GitHub Actions
              const totalVulns = summary.vulnerabilityCounts.critical + 
                                summary.vulnerabilityCounts.high + 
                                summary.vulnerabilityCounts.moderate + 
                                summary.vulnerabilityCounts.low;

              const criticalHighCount = summary.vulnerabilityCounts.critical + summary.vulnerabilityCounts.high;

              console.log(`::set-output name=total-vulnerabilities::${totalVulns}`);
              console.log(`::set-output name=critical-high-count::${criticalHighCount}`);
              console.log(`::set-output name=report-generated::true`);

              console.log('‚úÖ Auditor√≠a completada exitosamente');
            } catch (error) {
              console.error('‚ùå Error en auditor√≠a:', error);
              process.exit(1);
            }
          })();
          EOF

      - name: üìÑ Generar reporte PDF profesional
        if: ${{ inputs.report_format == 'all' || inputs.report_format == 'pdf' }}
        run: |
          npm install pdfkit canvas
          
          node << 'EOF'
          const fs = require('fs');
          const PDFDocument = require('pdfkit');

          class ProfessionalPDFGenerator {
            constructor(data) {
              this.data = data;
              this.doc = new PDFDocument({ 
                margin: 40, 
                size: 'A4',
                info: {
                  Title: 'Reporte de Auditor√≠a de Dependencias',
                  Author: 'Security Audit System',
                  Subject: 'An√°lisis de vulnerabilidades y dependencias',
                  Keywords: 'security, dependencies, vulnerabilities, audit'
                }
              });
              
              this.colors = {
                primary: '#1e3a8a',      // Azul profundo
                secondary: '#1f2937',     // Gris oscuro
                accent: '#3b82f6',        // Azul brillante
                success: '#059669',       // Verde
                warning: '#d97706',       // Naranja
                danger: '#dc2626',        // Rojo
                critical: '#7c2d12',      // Rojo oscuro
                background: '#f8fafc',    // Gris muy claro
                white: '#ffffff'
              };

              this.vulnerabilityColors = {
                critical: { bg: '#fef2f2', border: '#dc2626', text: '#7f1d1d' },
                high: { bg: '#fff7ed', border: '#ea580c', text: '#9a3412' },
                moderate: { bg: '#fffbeb', border: '#d97706', text: '#92400e' },
                low: { bg: '#f0fdf4', border: '#059669', text: '#064e3b' },
                none: { bg: '#f8fafc', border: '#6b7280', text: '#374151' }
              };
            }

            async generate() {
              console.log('üìÑ Generando PDF profesional...');
              
              this.doc.pipe(fs.createWriteStream('security-audit-report.pdf'));
              
              await this.createCoverPage();
              await this.createExecutiveSummary();
              await this.createVulnerabilityOverview();
              await this.createTopVulnerabilities();
              await this.createDependencyTable();
              await this.createRecommendations();
              await this.createAppendix();
              
              this.doc.end();
              console.log('‚úÖ PDF generado: security-audit-report.pdf');
            }

            async createCoverPage() {
              // Fondo degradado
              const gradient = this.doc.linearGradient(0, 0, 0, this.doc.page.height);
              gradient.stop(0, this.colors.primary);
              gradient.stop(1, this.colors.accent);
              
              this.doc.rect(0, 0, this.doc.page.width, this.doc.page.height).fill(gradient);

              // Logo/Icono (simulado con texto)
              this.doc.fontSize(48)
                .fillColor(this.colors.white)
                .text('üîí', this.doc.page.width / 2 - 30, 150);

              // T√≠tulo principal
              this.doc.fontSize(32)
                .font('Helvetica-Bold')
                .fillColor(this.colors.white)
                .text('REPORTE DE AUDITOR√çA', 0, 220, { align: 'center' });
                
              this.doc.fontSize(28)
                .text('DE SEGURIDAD', 0, 260, { align: 'center' });

              // Subt√≠tulo
              this.doc.fontSize(16)
                .font('Helvetica')
                .fillColor('#e2e8f0')
                .text('An√°lisis Completo de Dependencias y Vulnerabilidades', 0, 320, { align: 'center' });

              // Informaci√≥n del proyecto
              const projectInfo = [
                `üìä Total Dependencias: ${this.data.summary.totalDependencies}`,
                `üö® Vulnerabilidades Cr√≠ticas: ${this.data.summary.vulnerabilityCounts.critical}`,
                `‚ö†Ô∏è Vulnerabilidades Altas: ${this.data.summary.vulnerabilityCounts.high}`,
                `üìÖ Fecha de An√°lisis: ${new Date(this.data.summary.date).toLocaleDateString()}`
              ];

              let yPos = 400;
              projectInfo.forEach(info => {
                this.doc.fontSize(14)
                  .fillColor(this.colors.white)
                  .text(info, 0, yPos, { align: 'center' });
                yPos += 25;
              });

              // L√≠nea decorativa
              this.doc.moveTo(100, 550)
                .lineTo(this.doc.page.width - 100, 550)
                .strokeColor(this.colors.white)
                .lineWidth(2)
                .stroke();

              // Footer
              this.doc.fontSize(12)
                .fillColor('#cbd5e1')
                .text('Generado autom√°ticamente por el sistema de auditor√≠a de seguridad', 0, 700, { align: 'center' });

              this.doc.addPage();
            }

            async createExecutiveSummary() {
              this.addHeader('üìä RESUMEN EJECUTIVO');

              // Estad√≠sticas principales en cards
              const stats = [
                { 
                  title: 'Total Dependencias', 
                  value: this.data.summary.totalDependencies, 
                  color: this.colors.primary,
                  icon: 'üì¶'
                },
                { 
                  title: 'Vulnerabilidades Cr√≠ticas', 
                  value: this.data.summary.vulnerabilityCounts.critical, 
                  color: this.colors.danger,
                  icon: 'üö®'
                },
                { 
                  title: 'Vulnerabilidades Altas', 
                  value: this.data.summary.vulnerabilityCounts.high, 
                  color: this.colors.warning,
                  icon: '‚ö†Ô∏è'
                },
                { 
                  title: 'Paquetes Seguros', 
                  value: this.data.summary.vulnerabilityCounts.none, 
                  color: this.colors.success,
                  icon: '‚úÖ'
                }
              ];

              let xPos = 60;
              const cardWidth = 120;
              const cardHeight = 80;
              
              stats.forEach(stat => {
                // Card background
                this.doc.rect(xPos, this.doc.y, cardWidth, cardHeight)
                  .fillAndStroke(this.colors.white, stat.color);

                // Icon
                this.doc.fontSize(20)
                  .fillColor(stat.color)
                  .text(stat.icon, xPos + 10, this.doc.y + 10);

                // Value
                this.doc.fontSize(24)
                  .font('Helvetica-Bold')
                  .fillColor(stat.color)
                  .text(stat.value.toString(), xPos + 40, this.doc.y + 10);

                // Title
                this.doc.fontSize(10)
                  .font('Helvetica')
                  .fillColor(this.colors.secondary)
                  .text(stat.title, xPos + 5, this.doc.y + 50, { width: cardWidth - 10, align: 'center' });

                xPos += cardWidth + 20;
              });

              this.doc.moveDown(6);

              // Distribuci√≥n de riesgo
              this.addSubHeader('üìà Distribuci√≥n de Riesgo');
              
              const riskData = Object.entries(this.data.summary.riskDistribution)
                .filter(([_, count]) => count > 0)
                .sort(([_, a], [__, b]) => b - a);

              riskData.forEach(([risk, count]) => {
                const percentage = ((count / this.data.summary.totalDependencies) * 100).toFixed(1);
                this.doc.fontSize(12)
                  .fillColor(this.colors.secondary)
                  .text(`${risk}: ${count} paquetes (${percentage}%)`);
                this.doc.moveDown(0.3);
              });

              this.doc.addPage();
            }

            async createVulnerabilityOverview() {
              this.addHeader('üîç PANORAMA DE VULNERABILIDADES');

              if (this.data.summary.vulnerabilityCounts.critical + this.data.summary.vulnerabilityCounts.high === 0) {
                this.doc.fontSize(16)
                  .fillColor(this.colors.success)
                  .text('‚úÖ ¬°Excelente! No se encontraron vulnerabilidades cr√≠ticas o altas.', { align: 'center' });
                this.doc.moveDown(2);
              } else {
                // Gr√°fico de barras simple de vulnerabilidades
                const vulnTypes = ['critical', 'high', 'moderate', 'low'];
                const vulnLabels = ['Cr√≠ticas', 'Altas', 'Moderadas', 'Bajas'];
                const maxCount = Math.max(...vulnTypes.map(type => this.data.summary.vulnerabilityCounts[type]));
                
                this.addSubHeader('üìä Distribuci√≥n por Severidad');
                
                vulnTypes.forEach((type, index) => {
                  const count = this.data.summary.vulnerabilityCounts[type];
                  const barWidth = maxCount > 0 ? (count / maxCount) * 300 : 0;
                  const color = this.vulnerabilityColors[type];
                  
                  // Label
                  this.doc.fontSize(12)
                    .fillColor(this.colors.secondary)
                    .text(`${vulnLabels[index]}:`, 60, this.doc.y);
                  
                  // Barra
                  this.doc.rect(150, this.doc.y - 5, barWidth, 15)
                    .fill(color.border);
                  
                  // Valor
                  this.doc.fontSize(12)
                    .fillColor(this.colors.secondary)
                    .text(count.toString(), 460, this.doc.y - 12);
                  
                  this.doc.moveDown(1.2);
                });
              }

              this.doc.addPage();
            }

            async createTopVulnerabilities() {
              this.addHeader('üö® VULNERABILIDADES PRIORITARIAS');

              if (this.data.summary.topVulnerable.length === 0) {
                this.doc.fontSize(14)
                  .fillColor(this.colors.success)
                  .text('‚úÖ No se encontraron paquetes con vulnerabilidades.');
                this.doc.addPage();
                return;
              }

              this.data.summary.topVulnerable.slice(0, 10).forEach((pkg, index) => {
                const color = this.vulnerabilityColors[pkg.severity];
                
                // Card para cada vulnerabilidad
                const cardY = this.doc.y;
                this.doc.rect(50, cardY, 500, 60)
                  .fillAndStroke(color.bg, color.border);

                // Ranking
                this.doc.fontSize(18)
                  .font('Helvetica-Bold')
                  .fillColor(color.border)
                  .text(`#${index + 1}`, 60, cardY + 10);

                // Nombre del paquete
                this.doc.fontSize(14)
                  .font('Helvetica-Bold')
                  .fillColor(this.colors.secondary)
                  .text(pkg.name, 90, cardY + 8);

                // Versi√≥n
                this.doc.fontSize(10)
                  .font('Helvetica')
                  .fillColor(this.colors.secondary)
                  .text(`v${pkg.currentVersion}`, 90, cardY + 25);

                // Severidad
                this.doc.fontSize(12)
                  .font('Helvetica-Bold')
                  .fillColor(color.text)
                  .text(pkg.severity.toUpperCase(), 300, cardY + 10);

                // Contador de vulnerabilidades
                this.doc.fontSize(16)
                  .font('Helvetica-Bold')
                  .fillColor(color.border)
                  .text(`${pkg.vulnerabilityCount}`, 450, cardY + 8);

                this.doc.fontSize(10)
                  .font('Helvetica')
                  .fillColor(this.colors.secondary)
                  .text('vulnerabilidades', 420, cardY + 30);

                // Recomendaci√≥n
                this.doc.fontSize(10)
                  .font('Helvetica')
                  .fillColor(this.colors.secondary)
                  .text(pkg.recommendation, 90, cardY + 40, { width: 300 });

                this.doc.y = cardY + 75;
              });

              this.doc.addPage();
            }

            async createDependencyTable() {
              this.addHeader('üìã TABLA DE DEPENDENCIAS');

              // Configuraci√≥n de la tabla
              const tableHeaders = ['Paquete', 'Versi√≥n', '√öltima', 'Severidad', 'Riesgo', 'D√≠as'];
              const colWidths = [120, 60, 60, 70, 70, 50];
              const tableX = 50;
              let tableY = this.doc.y;

              // Headers de la tabla
              this.doc.rect(tableX, tableY, colWidths.reduce((a, b) => a + b, 0), 25)
                .fill(this.colors.primary);

              let xPos = tableX;
              tableHeaders.forEach((header, i) => {
                this.doc.fontSize(10)
                  .font('Helvetica-Bold')
                  .fillColor(this.colors.white)
                  .text(header, xPos + 5, tableY + 8, { width: colWidths[i] - 10 });
                xPos += colWidths[i];
              });

              tableY += 25;

              // Filtrar y ordenar dependencias por severidad
              const sortedDeps = this.data.dependencies
                .filter(dep => !dep.isDev || process.env.INCLUDE_DEV === 'true')
                .sort((a, b) => {
                  const severityOrder = { critical: 0, high: 1, moderate: 2, low: 3, none: 4 };
                  return severityOrder[a.severity] - severityOrder[b.severity];
                })
                .slice(0, 50); // Limitar a 50 para evitar p√°ginas excesivas

              sortedDeps.forEach((dep, index) => {
                // Alternar colores de fila
                const rowColor = index % 2 === 0 ? this.colors.white : this.colors.background;
                
                this.doc.rect(tableX, tableY, colWidths.reduce((a, b) => a + b, 0), 20)
                  .fill(rowColor);

                // Color de borde seg√∫n severidad
                const vulnColor = this.vulnerabilityColors[dep.severity];
                this.doc.rect(tableX, tableY, 5, 20).fill(vulnColor.border);

                // Contenido de las celdas
                const cellData = [
                  dep.name.length > 15 ? dep.name.substring(0, 15) + '...' : dep.name,
                  dep.currentVersion,
                  dep.latestVersion === 'N/A' ? 'N/A' : dep.latestVersion,
                  dep.severity === 'none' ? '‚úÖ' : dep.severity.charAt(0).toUpperCase(),
                  dep.riskLevel,
                  dep.daysSinceUpdate ? dep.daysSinceUpdate.toString() : 'N/A'
                ];

                xPos = tableX + 5;
                cellData.forEach((data, i) => {
                  this.doc.fontSize(8)
                    .font('Helvetica')
                    .fillColor(this.colors.secondary)
                    .text(data, xPos, tableY + 6, { width: colWidths[i] - 10 });
                  xPos += colWidths[i];
                });

                tableY += 20;

                // Nueva p√°gina si es necesario
                if (tableY > 700) {
                  this.doc.addPage();
                  tableY = 100;
                }
              });

              this.doc.y = tableY + 20;
              this.doc.addPage();
            }

            async createRecommendations() {
              this.addHeader('üí° RECOMENDACIONES DE SEGURIDAD');

              const recommendations = [
                {
                  priority: 'CR√çTICA',
                  icon: 'üö®',
                  title: 'Vulnerabilidades Cr√≠ticas',
                  action: 'Actualizar inmediatamente todos los paquetes con vulnerabilidades cr√≠ticas',
                  timeline: 'Dentro de 24 horas',
                  color: this.colors.danger
                },
                {
                  priority: 'ALTA',
                  icon: '‚ö°',
                  title: 'Vulnerabilidades Altas',
                  action: 'Programar actualizaciones de paquetes con vulnerabilidades altas',
                  timeline: 'Dentro de 1 semana',
                  color: this.colors.warning
                },
                {
                  priority: 'MEDIA',
                  icon: 'üìÖ',
                  title: 'Mantenimiento Regular',
                  action: 'Establecer calendario de actualizaciones mensuales',
                  timeline: 'Pr√≥ximo mes',
                  color: this.colors.primary
                },
                {
                  priority: 'PREVENTIVA',
                  icon: 'üîç',
                  title: 'Monitoreo Continuo',
                  action: 'Implementar auditor√≠as autom√°ticas semanales',
                  timeline: 'Configurar esta semana',
                  color: this.colors.success
                }
              ];

              recommendations.forEach((rec, index) => {
                const cardY = this.doc.y;
                
                // Card background
                this.doc.rect(50, cardY, 500, 70)
                  .fillAndStroke(this.colors.white, rec.color);

                // Icono y prioridad
                this.doc.fontSize(20)
                  .text(rec.icon, 65, cardY + 15);

                this.doc.fontSize(12)
                  .font('Helvetica-Bold')
                  .fillColor(rec.color)
                  .text(rec.priority, 100, cardY + 10);

                // T√≠tulo
                this.doc.fontSize(14)
                  .font('Helvetica-Bold')
                  .fillColor(this.colors.secondary)
                  .text(rec.title, 100, cardY + 25);

                // Acci√≥n
                this.doc.fontSize(11)
                  .font('Helvetica')
                  .fillColor(this.colors.secondary)
                  .text(rec.action, 100, cardY + 42, { width: 300 });

                // Timeline
                this.doc.fontSize(10)
                  .font('Helvetica-Bold')
                  .fillColor(rec.color)
                  .text(`‚è±Ô∏è ${rec.timeline}`, 420, cardY + 15);

                this.doc.y = cardY + 85;
              });

              // Comandos √∫tiles
              this.addSubHeader('üõ†Ô∏è Comandos √ötiles');
              
              const commands = [
                'npm audit fix          # Arreglar vulnerabilidades autom√°ticamente',
                'npm audit fix --force  # Forzar correcciones (puede romper compatibilidad)',
                'npm outdated          # Ver paquetes desactualizados',
                'npm update             # Actualizar paquetes menores',
                'npm install package@latest # Actualizar paquete espec√≠fico'
              ];

              commands.forEach(cmd => {
                this.doc.fontSize(10)
                  .font('Courier')
                  .fillColor(this.colors.secondary)
                  .text(cmd, 60);
                this.doc.moveDown(0.5);
              });

              this.doc.addPage();
            }

            async createAppendix() {
              this.addHeader('üìö AP√âNDICE');

              // Glosario de t√©rminos
              this.addSubHeader('üìñ Glosario de T√©rminos');
              
              const glossary = [
                { term: 'Vulnerabilidad Cr√≠tica', definition: 'Falla de seguridad que permite ejecuci√≥n remota de c√≥digo o acceso completo al sistema.' },
                { term: 'Vulnerabilidad Alta', definition: 'Falla que puede comprometer significativamente la seguridad de la aplicaci√≥n.' },
                { term: 'Vulnerabilidad Moderada', definition: 'Problema de seguridad con riesgo limitado pero que requiere atenci√≥n.' },
                { term: 'Vulnerabilidad Baja', definition: 'Problema menor de seguridad con riesgo m√≠nimo para la aplicaci√≥n.' },
                { term: 'Dependencia Obsoleta', definition: 'Paquete que no ha sido actualizado por m√°s de 2 a√±os.' },
                { term: 'CVE', definition: 'Common Vulnerabilities and Exposures - Identificador √∫nico para vulnerabilidades conocidas.' }
              ];

              glossary.forEach(item => {
                this.doc.fontSize(11)
                  .font('Helvetica-Bold')
                  .fillColor(this.colors.primary)
                  .text(`${item.term}:`, 60);
                
                this.doc.fontSize(10)
                  .font('Helvetica')
                  .fillColor(this.colors.secondary)
                  .text(item.definition, 60, this.doc.y, { width: 480 });
                
                this.doc.moveDown(1);
              });

              // Informaci√≥n adicional
              this.addSubHeader('‚ÑπÔ∏è Informaci√≥n del Sistema');
              
              const systemInfo = [
                `Fecha de generaci√≥n: ${new Date().toLocaleString()}`,
                `Versi√≥n de Node.js: ${process.env.NODE_VERSION || 'N/A'}`,
                `Herramienta de auditor√≠a: npm audit`,
                `Nivel de auditor√≠a: ${process.env.AUDIT_LEVEL || 'info'}`,
                `Dependencias de desarrollo incluidas: ${process.env.INCLUDE_DEV === 'true' ? 'S√≠' : 'No'}`
              ];

              systemInfo.forEach(info => {
                this.doc.fontSize(10)
                  .fillColor(this.colors.secondary)
                  .text(`‚Ä¢ ${info}`, 60);
                this.doc.moveDown(0.3);
              });

              // Footer final
              this.doc.moveDown(3);
              this.doc.fontSize(8)
                .fillColor(this.colors.secondary)
                .text('Este reporte fue generado autom√°ticamente por el sistema de auditor√≠a de seguridad.', 0, this.doc.y, { align: 'center' });
              this.doc.text('Para m√°s informaci√≥n, consulte la documentaci√≥n del proyecto.', 0, this.doc.y + 10, { align: 'center' });
            }

            addHeader(title) {
              this.doc.fontSize(20)
                .font('Helvetica-Bold')
                .fillColor(this.colors.primary)
                .text(title, 50);
              
              // L√≠nea decorativa
              this.doc.moveTo(50, this.doc.y + 5)
                .lineTo(550, this.doc.y + 5)
                .strokeColor(this.colors.accent)
                .lineWidth(2)
                .stroke();
              
              this.doc.moveDown(2);
            }

            addSubHeader(title) {
              this.doc.moveDown(1);
              this.doc.fontSize(14)
                .font('Helvetica-Bold')
                .fillColor(this.colors.secondary)
                .text(title, 50);
              this.doc.moveDown(0.5);
            }
          }

          // Generar el PDF
          (async () => {
            try {
              const reportData = JSON.parse(fs.readFileSync('audit-complete-report.json', 'utf8'));
              const pdfGenerator = new ProfessionalPDFGenerator(reportData);
              await pdfGenerator.generate();
              console.log('‚úÖ PDF profesional generado exitosamente');
            } catch (error) {
              console.error('‚ùå Error generando PDF:', error);
              // Continuar sin fallar el workflow
            }
          })();
          EOF

      - name: üì§ Subir artefactos del reporte
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-audit-reports-${{ github.run_number }}
          path: |
            audit-complete-report.json
            audit-summary.json
            audit-summary.txt
            security-audit-report.pdf
            dependency-tree.json
            direct-dependencies.json
          retention-days: 30

      - name: üí¨ Comentar en PR (si aplica)
        if: github.event_name == 'pull_request' && steps.audit-summary.outputs.critical-high-count != '0'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const summary = fs.readFileSync('audit-summary.txt', 'utf8');
            
            const comment = `## üîí Reporte de Auditor√≠a de Seguridad
            
            ${summary}
            
            üìä **Archivos generados:**
            - üìÑ Reporte PDF profesional
            - üìã Datos completos en JSON
            - üìà Resumen ejecutivo
            
            Para ver el reporte completo, descarga los artefactos de este workflow.
            
            ${steps.audit-summary.outputs.critical-high-count > 0 ? '‚ö†Ô∏è **ACCI√ìN REQUERIDA:** Se encontraron vulnerabilidades cr√≠ticas o altas que requieren atenci√≥n inmediata.' : '‚úÖ No se encontraron vulnerabilidades cr√≠ticas.'}`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

      - name: üö® Fallar si hay vulnerabilidades cr√≠ticas
        if: steps.audit-summary.outputs.critical-high-count != '0'
        run: |
          echo "‚ùå Se encontraron ${{ steps.audit-summary.outputs.critical-high-count }} vulnerabilidades cr√≠ticas/altas"
          echo "üìä Total de vulnerabilidades: ${{ steps.audit-summary.outputs.total-vulnerabilities }}"
          echo "üìÑ Revisa el reporte PDF generado para m√°s detalles"
          exit 1

      - name: ‚úÖ √âxito - Sin vulnerabilidades cr√≠ticas
        if: steps.audit-summary.outputs.critical-high-count == '0'
        run: |
          echo "‚úÖ ¬°Excelente! No se encontraron vulnerabilidades cr√≠ticas"
          echo "üìä Total de vulnerabilidades encontradas: ${{ steps.audit-summary.outputs.total-vulnerabilities }}"
          echo "üìÑ Reporte completo disponible en los artefactos"
name: üîí Auditor√≠a Profesional de Dependencias y Vulnerabilidades

on:
  workflow_dispatch:
    inputs:
      include_dev_dependencies:
        description: 'Incluir dependencias de desarrollo'
        required: false
        default: true
        type: boolean
      report_format:
        description: 'Formato del reporte'
        required: false
        default: 'all'
        type: choice
        options:
        - all
        - pdf
        - json
  push:
    branches: ['**']
    paths: ['package.json', 'package-lock.json', 'yarn.lock']
  pull_request:
    branches: ['**']
    paths: ['package.json', 'package-lock.json', 'yarn.lock']
  schedule:
    - cron: '0 2 * * 1' # Lunes a las 2 AM

env:
  NODE_VERSION: '20'
  AUDIT_LEVEL: 'info'

jobs:
  security-audit:
    name: üõ°Ô∏è Auditor√≠a de Seguridad
    runs-on: ubuntu-latest
    timeout-minutes: 15

    permissions:
      contents: read
      security-events: write
      pull-requests: write

    outputs:
      total-vulnerabilities: ${{ steps.audit-summary.outputs.total-vulnerabilities }}
      critical-high-count: ${{ steps.audit-summary.outputs.critical-high-count }}
      report-generated: ${{ steps.audit-summary.outputs.report-generated }}

    steps:
      - name: üì• Checkout del c√≥digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üü¢ Configurar Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: üì¶ Instalar dependencias
        run: |
          npm ci --prefer-offline --no-audit --no-fund
          echo "‚úÖ Dependencias instaladas correctamente"

      - name: üìã Inventario de dependencias
        run: |
          echo "üìä Generando inventario completo de dependencias..."
          npm list --all --json > dependency-tree.json
          npm list --depth=0 --json > direct-dependencies.json
          
          # Estad√≠sticas b√°sicas
          TOTAL_DEPS=$(jq -r '.dependencies | keys | length' direct-dependencies.json 2>/dev/null || echo "0")
          echo "üì¶ Total dependencias directas: $TOTAL_DEPS"
          echo "TOTAL_DEPENDENCIES=$TOTAL_DEPS" >> $GITHUB_ENV

      - name: üîç Ejecutar auditor√≠a de seguridad
        id: security-audit
        run: |
          echo "üîç Iniciando auditor√≠a de seguridad..."
          
          # Ejecutar audit y capturar resultado
          set +e
          npm audit --json > audit-raw.json
          AUDIT_EXIT_CODE=$?
          set -e
          
          echo "AUDIT_EXIT_CODE=$AUDIT_EXIT_CODE" >> $GITHUB_ENV
          
          if [ $AUDIT_EXIT_CODE -eq 0 ]; then
            echo "‚úÖ No se encontraron vulnerabilidades"
          else
            echo "‚ö†Ô∏è Se encontraron vulnerabilidades (c√≥digo: $AUDIT_EXIT_CODE)"
          fi

      - name: üßÆ Procesar resultados de auditor√≠a
        id: audit-summary
        run: |
          node << 'EOF'
          const fs = require('fs');
          const https = require('https');
          const { execSync } = require('child_process');

          class DependencyAuditor {
            constructor() {
              this.auditData = {};
              this.dependencyTree = {};
              this.npmCache = new Map();
              this.reportData = [];
            }

            async initialize() {
              try {
                console.log('üìä Inicializando auditor de dependencias...');
                
                // Cargar datos de auditor√≠a
                const auditRaw = fs.readFileSync('audit-raw.json', 'utf8');
                this.auditData = JSON.parse(auditRaw);
                
                // Cargar √°rbol de dependencias
                const treeRaw = fs.readFileSync('dependency-tree.json', 'utf8');
                this.dependencyTree = JSON.parse(treeRaw);
                
                console.log('‚úÖ Datos cargados correctamente');
              } catch (error) {
                console.error('‚ùå Error inicializando:', error.message);
                throw error;
              }
            }

            extractAllDependencies() {
              const allDeps = new Map();
              
              const traverse = (deps, isDevDep = false) => {
                if (!deps) return;
                
                for (const [name, info] of Object.entries(deps)) {
                  if (!allDeps.has(name)) {
                    allDeps.set(name, {
                      version: info.version || 'unknown',
                      isDev: isDevDep,
                      path: info.path || name
                    });
                  }
                  traverse(info.dependencies, isDevDep);
                }
              };

              traverse(this.dependencyTree.dependencies, false);
              traverse(this.dependencyTree.devDependencies, true);
              
              return allDeps;
            }

            async fetchNpmMetadata(packageName) {
              if (this.npmCache.has(packageName)) {
                return this.npmCache.get(packageName);
              }

              return new Promise((resolve) => {
                const options = {
                  hostname: 'registry.npmjs.org',
                  path: `/${encodeURIComponent(packageName)}`,
                  method: 'GET',
                  timeout: 5000
                };

                const req = https.request(options, (res) => {
                  let data = '';
                  
                  res.on('data', chunk => data += chunk);
                  res.on('end', () => {
                    try {
                      const pkg = JSON.parse(data);
                      const metadata = {
                        latestVersion: pkg['dist-tags']?.latest || null,
                        description: pkg.description || '',
                        homepage: pkg.homepage || '',
                        repository: pkg.repository?.url || '',
                        license: pkg.license || 'Unknown',
                        maintainers: pkg.maintainers?.length || 0,
                        lastPublish: this.getLastPublishDate(pkg),
                        weeklyDownloads: null // Se podr√≠a obtener de otra API
                      };
                      
                      this.npmCache.set(packageName, metadata);
                      resolve(metadata);
                    } catch (error) {
                      console.warn(`‚ö†Ô∏è Error parsing metadata for ${packageName}`);
                      resolve(this.getDefaultMetadata());
                    }
                  });
                });

                req.on('error', () => {
                  console.warn(`‚ö†Ô∏è Error fetching metadata for ${packageName}`);
                  resolve(this.getDefaultMetadata());
                });

                req.on('timeout', () => {
                  req.destroy();
                  resolve(this.getDefaultMetadata());
                });

                req.end();
              });
            }

            getLastPublishDate(pkg) {
              if (!pkg.time) return null;
              
              const versions = Object.keys(pkg.versions || {});
              if (versions.length === 0) return null;
              
              const latestVersion = pkg['dist-tags']?.latest;
              return pkg.time[latestVersion] || Object.values(pkg.time).sort().pop();
            }

            getDefaultMetadata() {
              return {
                latestVersion: null,
                description: '',
                homepage: '',
                repository: '',
                license: 'Unknown',
                maintainers: 0,
                lastPublish: null,
                weeklyDownloads: null
              };
            }

            analyzeVulnerabilities() {
              const vulnMap = new Map();
              
              if (this.auditData.vulnerabilities) {
                for (const [pkgName, vuln] of Object.entries(this.auditData.vulnerabilities)) {
                  const severity = vuln.severity || 'unknown';
                  const count = Array.isArray(vuln.via) ? vuln.via.length : 1;
                  
                  vulnMap.set(pkgName, {
                    severity,
                    count,
                    title: vuln.title || 'Vulnerabilidad sin t√≠tulo',
                    range: vuln.range || '*',
                    nodes: vuln.nodes || [],
                    fixAvailable: vuln.fixAvailable || false
                  });
                }
              }
              
              return vulnMap;
            }

            getRiskLevel(severity, lastPublish) {
              if (severity === 'critical') return 'CR√çTICO';
              if (severity === 'high') return 'ALTO';
              if (severity === 'moderate') return 'MEDIO';
              if (severity === 'low') return 'BAJO';
              
              // Evaluar riesgo por antiguedad
              if (lastPublish) {
                const daysSinceUpdate = (Date.now() - new Date(lastPublish)) / (1000 * 60 * 60 * 24);
                if (daysSinceUpdate > 730) return 'OBSOLETO'; // 2 a√±os
                if (daysSinceUpdate > 365) return 'ANTIGUO'; // 1 a√±o
              }
              
              return 'SEGURO';
            }

            getRecommendation(vulnerability, metadata, currentVersion) {
              if (!vulnerability) {
                if (metadata.latestVersion && currentVersion !== metadata.latestVersion) {
                  return `Actualizar a ${metadata.latestVersion}`;
                }
                return 'Mantener versi√≥n actual';
              }

              const { severity, fixAvailable } = vulnerability;
              
              if (severity === 'critical') {
                return fixAvailable ? 'üö® ACTUALIZAR INMEDIATAMENTE' : 'üö® REEMPLAZAR PAQUETE';
              }
              
              if (severity === 'high') {
                return fixAvailable ? '‚ö° Actualizar con prioridad alta' : '‚ö†Ô∏è Buscar alternativas';
              }
              
              if (severity === 'moderate') {
                return fixAvailable ? 'üìÖ Actualizar pr√≥ximamente' : 'üîç Revisar impacto';
              }
              
              return fixAvailable ? 'üìù Considerar actualizaci√≥n' : 'üëÄ Monitorear';
            }

            async generateReport() {
              console.log('üìä Generando reporte detallado...');
              
              const allDeps = this.extractAllDependencies();
              const vulnerabilities = this.analyzeVulnerabilities();
              
              console.log(`üì¶ Analizando ${allDeps.size} dependencias...`);
              
              let processed = 0;
              for (const [name, depInfo] of allDeps) {
                const metadata = await this.fetchNpmMetadata(name);
                const vulnerability = vulnerabilities.get(name);
                
                const riskLevel = this.getRiskLevel(
                  vulnerability?.severity, 
                  metadata.lastPublish
                );
                
                this.reportData.push({
                  name,
                  currentVersion: depInfo.version,
                  latestVersion: metadata.latestVersion || 'N/A',
                  description: metadata.description.substring(0, 100),
                  license: metadata.license,
                  lastPublish: metadata.lastPublish ? 
                    new Date(metadata.lastPublish).toISOString().split('T')[0] : 'N/A',
                  daysSinceUpdate: metadata.lastPublish ? 
                    Math.floor((Date.now() - new Date(metadata.lastPublish)) / (1000 * 60 * 60 * 24)) : null,
                  severity: vulnerability?.severity || 'none',
                  vulnerabilityCount: vulnerability?.count || 0,
                  vulnerabilityTitle: vulnerability?.title || '',
                  riskLevel,
                  recommendation: this.getRecommendation(vulnerability, metadata, depInfo.version),
                  isDev: depInfo.isDev,
                  maintainers: metadata.maintainers,
                  homepage: metadata.homepage,
                  repository: metadata.repository
                });
                
                processed++;
                if (processed % 10 === 0) {
                  console.log(`üìä Procesadas ${processed}/${allDeps.size} dependencias...`);
                }
              }
              
              console.log('‚úÖ Reporte generado completamente');
            }

            generateSummary() {
              const summary = {
                date: new Date().toISOString(),
                totalDependencies: this.reportData.length,
                productionDependencies: this.reportData.filter(d => !d.isDev).length,
                devDependencies: this.reportData.filter(d => d.isDev).length,
                vulnerabilityCounts: {
                  critical: this.reportData.filter(d => d.severity === 'critical').length,
                  high: this.reportData.filter(d => d.severity === 'high').length,
                  moderate: this.reportData.filter(d => d.severity === 'moderate').length,
                  low: this.reportData.filter(d => d.severity === 'low').length,
                  none: this.reportData.filter(d => d.severity === 'none').length
                },
                riskDistribution: {},
                topVulnerable: this.reportData
                  .filter(d => d.vulnerabilityCount > 0)
                  .sort((a, b) => b.vulnerabilityCount - a.vulnerabilityCount)
                  .slice(0, 10),
                outdatedPackages: this.reportData
                  .filter(d => d.daysSinceUpdate && d.daysSinceUpdate > 365)
                  .sort((a, b) => b.daysSinceUpdate - a.daysSinceUpdate)
                  .slice(0, 10),
                updateCandidates: this.reportData
                  .filter(d => d.latestVersion !== 'N/A' && d.currentVersion !== d.latestVersion)
                  .slice(0, 20)
              };

              // Calcular distribuci√≥n de riesgo
              ['CR√çTICO', 'ALTO', 'MEDIO', 'BAJO', 'SEGURO', 'OBSOLETO', 'ANTIGUO'].forEach(risk => {
                summary.riskDistribution[risk] = this.reportData.filter(d => d.riskLevel === risk).length;
              });

              return summary;
            }

            saveReports() {
              const summary = this.generateSummary();
              
              // Guardar datos completos
              fs.writeFileSync('audit-complete-report.json', JSON.stringify({
                summary,
                dependencies: this.reportData
              }, null, 2));

              // Guardar resumen para GitHub Actions
              fs.writeFileSync('audit-summary.json', JSON.stringify(summary, null, 2));

              // Resumen en texto
              let textReport = `üîí REPORTE DE AUDITOR√çA DE SEGURIDAD\n`;
              textReport += `üìÖ Fecha: ${new Date().toLocaleString()}\n\n`;
              textReport += `üìä RESUMEN EJECUTIVO:\n`;
              textReport += `‚îú‚îÄ Total dependencias: ${summary.totalDependencies}\n`;
              textReport += `‚îú‚îÄ Producci√≥n: ${summary.productionDependencies}\n`;
              textReport += `‚îú‚îÄ Desarrollo: ${summary.devDependencies}\n`;
              textReport += `‚îî‚îÄ Vulnerabilidades cr√≠ticas/altas: ${summary.vulnerabilityCounts.critical + summary.vulnerabilityCounts.high}\n\n`;

              if (summary.topVulnerable.length > 0) {
                textReport += `üö® TOP VULNERABILIDADES:\n`;
                summary.topVulnerable.slice(0, 5).forEach((pkg, i) => {
                  textReport += `${i + 1}. ${pkg.name}@${pkg.currentVersion} - ${pkg.vulnerabilityCount} vulnerabilidades (${pkg.severity.toUpperCase()})\n`;
                });
              } else {
                textReport += `‚úÖ No se encontraron vulnerabilidades cr√≠ticas\n`;
              }

              fs.writeFileSync('audit-summary.txt', textReport);

              return summary;
            }
          }

          // Ejecutar auditor√≠a
          (async () => {
            try {
              const auditor = new DependencyAuditor();
              await auditor.initialize();
              await auditor.generateReport();
              const summary = auditor.saveReports();

              // Configurar outputs para GitHub Actions
              const totalVulns = summary.vulnerabilityCounts.critical + 
                                summary.vulnerabilityCounts.high + 
                                summary.vulnerabilityCounts.moderate + 
                                summary.vulnerabilityCounts.low;

              const criticalHighCount = summary.vulnerabilityCounts.critical + summary.vulnerabilityCounts.high;

              console.log(`::set-output name=total-vulnerabilities::${totalVulns}`);
              console.log(`::set-output name=critical-high-count::${criticalHighCount}`);
              console.log(`::set-output name=report-generated::true`);

              console.log('‚úÖ Auditor√≠a completada exitosamente');
            } catch (error) {
              console.error('‚ùå Error en auditor√≠a:', error);
              process.exit(1);
            }
          })();
          EOF

      - name: üìÑ Generar reporte PDF profesional
        if: ${{ inputs.report_format == 'all' || inputs.report_format == 'pdf' }}
        run: |
          npm install pdfkit canvas
          
          node << 'EOF'
          const fs = require('fs');
          const PDFDocument = require('pdfkit');

          class ProfessionalPDFGenerator {
            constructor(data) {
              this.data = data;
              this.doc = new PDFDocument({ 
                margin: 40, 
                size: 'A4',
                info: {
                  Title: 'Reporte de Auditor√≠a de Dependencias',
                  Author: 'Security Audit System',
                  Subject: 'An√°lisis de vulnerabilidades y dependencias',
                  Keywords: 'security, dependencies, vulnerabilities, audit'
                }
              });
              
              this.colors = {
                primary: '#1e3a8a',      // Azul profundo
                secondary: '#1f2937',     // Gris oscuro
                accent: '#3b82f6',        // Azul brillante
                success: '#059669',       // Verde
                warning: '#d97706',       // Naranja
                danger: '#dc2626',        // Rojo
                critical: '#7c2d12',      // Rojo oscuro
                background: '#f8fafc',    // Gris muy claro
                white: '#ffffff'
              };

              this.vulnerabilityColors = {
                critical: { bg: '#fef2f2', border: '#dc2626', text: '#7f1d1d' },
                high: { bg: '#fff7ed', border: '#ea580c', text: '#9a3412' },
                moderate: { bg: '#fffbeb', border: '#d97706', text: '#92400e' },
                low: { bg: '#f0fdf4', border: '#059669', text: '#064e3b' },
                none: { bg: '#f8fafc', border: '#6b7280', text: '#374151' }
              };
            }

            async generate() {
              console.log('üìÑ Generando PDF profesional...');
              
              this.doc.pipe(fs.createWriteStream('security-audit-report.pdf'));
              
              await this.createCoverPage();
              await this.createExecutiveSummary();
              await this.createVulnerabilityOverview();
              await this.createTopVulnerabilities();
              await this.createDependencyTable();
              await this.createRecommendations();
              await this.createAppendix();
              
              this.doc.end();
              console.log('‚úÖ PDF generado: security-audit-report.pdf');
            }

            async createCoverPage() {
              // Fondo degradado
              const gradient = this.doc.linearGradient(0, 0, 0, this.doc.page.height);
              gradient.stop(0, this.colors.primary);
              gradient.stop(1, this.colors.accent);
              
              this.doc.rect(0, 0, this.doc.page.width, this.doc.page.height).fill(gradient);

              // Logo/Icono (simulado con texto)
              this.doc.fontSize(48)
                .fillColor(this.colors.white)
                .text('üîí', this.doc.page.width / 2 - 30, 150);

              // T√≠tulo principal
              this.doc.fontSize(32)
                .font('Helvetica-Bold')
                .fillColor(this.colors.white)
                .text('REPORTE DE AUDITOR√çA', 0, 220, { align: 'center' });
                
              this.doc.fontSize(28)
                .text('DE SEGURIDAD', 0, 260, { align: 'center' });

              // Subt√≠tulo
              this.doc.fontSize(16)
                .font('Helvetica')
                .fillColor('#e2e8f0')
                .text('An√°lisis Completo de Dependencias y Vulnerabilidades', 0, 320, { align: 'center' });

              // Informaci√≥n del proyecto
              const projectInfo = [
                `üìä Total Dependencias: ${this.data.summary.totalDependencies}`,
                `üö® Vulnerabilidades Cr√≠ticas: ${this.data.summary.vulnerabilityCounts.critical}`,
                `‚ö†Ô∏è Vulnerabilidades Altas: ${this.data.summary.vulnerabilityCounts.high}`,
                `üìÖ Fecha de An√°lisis: ${new Date(this.data.summary.date).toLocaleDateString()}`
              ];

              let yPos = 400;
              projectInfo.forEach(info => {
                this.doc.fontSize(14)
                  .fillColor(this.colors.white)
                  .text(info, 0, yPos, { align: 'center' });
                yPos += 25;
              });

              // L√≠nea decorativa
              this.doc.moveTo(100, 550)
                .lineTo(this.doc.page.width - 100, 550)
                .strokeColor(this.colors.white)
                .lineWidth(2)
                .stroke();

              // Footer
              this.doc.fontSize(12)
                .fillColor('#cbd5e1')
                .text('Generado autom√°ticamente por el sistema de auditor√≠a de seguridad', 0, 700, { align: 'center' });

              this.doc.addPage();
            }

            async createExecutiveSummary() {
              this.addHeader('üìä RESUMEN EJECUTIVO');

              // Estad√≠sticas principales en cards
              const stats = [
                { 
                  title: 'Total Dependencias', 
                  value: this.data.summary.totalDependencies, 
                  color: this.colors.primary,
                  icon: 'üì¶'
                },
                { 
                  title: 'Vulnerabilidades Cr√≠ticas', 
                  value: this.data.summary.vulnerabilityCounts.critical, 
                  color: this.colors.danger,
                  icon: 'üö®'
                },
                { 
                  title: 'Vulnerabilidades Altas', 
                  value: this.data.summary.vulnerabilityCounts.high, 
                  color: this.colors.warning,
                  icon: '‚ö†Ô∏è'
                },
                { 
                  title: 'Paquetes Seguros', 
                  value: this.data.summary.vulnerabilityCounts.none, 
                  color: this.colors.success,
                  icon: '‚úÖ'
                }
              ];

              let xPos = 60;
              const cardWidth = 120;
              const cardHeight = 80;
              
              stats.forEach(stat => {
                // Card background
                this.doc.rect(xPos, this.doc.y, cardWidth, cardHeight)
                  .fillAndStroke(this.colors.white, stat.color);

                // Icon
                this.doc.fontSize(20)
                  .fillColor(stat.color)
                  .text(stat.icon, xPos + 10, this.doc.y + 10);

                // Value
                this.doc.fontSize(24)
                  .font('Helvetica-Bold')
                  .fillColor(stat.color)
                  .text(stat.value.toString(), xPos + 40, this.doc.y + 10);

                // Title
                this.doc.fontSize(10)
                  .font('Helvetica')
                  .fillColor(this.colors.secondary)
                  .text(stat.title, xPos + 5, this.doc.y + 50, { width: cardWidth - 10, align: 'center' });

                xPos += cardWidth + 20;
              });

              this.doc.moveDown(6);

              // Distribuci√≥n de riesgo
              this.addSubHeader('üìà Distribuci√≥n de Riesgo');
              
              const riskData = Object.entries(this.data.summary.riskDistribution)
                .filter(([_, count]) => count > 0)
                .sort(([_, a], [__, b]) => b - a);

              riskData.forEach(([risk, count]) => {
                const percentage = ((count / this.data.summary.totalDependencies) * 100).toFixed(1);
                this.doc.fontSize(12)
                  .fillColor(this.colors.secondary)
                  .text(`${risk}: ${count} paquetes (${percentage}%)`);
                this.doc.moveDown(0.3);
              });

              this.doc.addPage();
            }

            async createVulnerabilityOverview() {
              this.addHeader('üîç PANORAMA DE VULNERABILIDADES');

              if (this.data.summary.vulnerabilityCounts.critical + this.data.summary.vulnerabilityCounts.high === 0) {
                this.doc.fontSize(16)
                  .fillColor(this.colors.success)
                  .text('‚úÖ ¬°Excelente! No se encontraron vulnerabilidades cr√≠ticas o altas.', { align: 'center' });
                this.doc.moveDown(2);
              } else {
                // Gr√°fico de barras simple de vulnerabilidades
                const vulnTypes = ['critical', 'high', 'moderate', 'low'];
                const vulnLabels = ['Cr√≠ticas', 'Altas', 'Moderadas', 'Bajas'];
                const maxCount = Math.max(...vulnTypes.map(type => this.data.summary.vulnerabilityCounts[type]));
                
                this.addSubHeader('üìä Distribuci√≥n por Severidad');
                
                vulnTypes.forEach((type, index) => {
                  const count = this.data.summary.vulnerabilityCounts[type];
                  const barWidth = maxCount > 0 ? (count / maxCount) * 300 : 0;
                  const color = this.vulnerabilityColors[type];
                  
                  // Label
                  this.doc.fontSize(12)
                    .fillColor(this.colors.secondary)
                    .text(`${vulnLabels[index]}:`, 60, this.doc.y);
                  
                  // Barra
                  this.doc.rect(150, this.doc.y - 5, barWidth, 15)
                    .fill(color.border);
                  
                  // Valor
                  this.doc.fontSize(12)
                    .fillColor(this.colors.secondary)
                    .text(count.toString(), 460, this.doc.y - 12);
                  
                  this.doc.moveDown(1.2);
                });
              }

              this.doc.addPage();
            }

            async createTopVulnerabilities() {
              this.addHeader('üö® VULNERABILIDADES PRIORITARIAS');

              if (this.data.summary.topVulnerable.length === 0) {
                this.doc.fontSize(14)
                  .fillColor(this.colors.success)
                  .text('‚úÖ No se encontraron paquetes con vulnerabilidades.');
                this.doc.addPage();
                return;
              }

              this.data.summary.topVulnerable.slice(0, 10).forEach((pkg, index) => {
                const color = this.vulnerabilityColors[pkg.severity];
                
                // Card para cada vulnerabilidad
                const cardY = this.doc.y;
                this.doc.rect(50, cardY, 500, 60)
                  .fillAndStroke(color.bg, color.border);

                // Ranking
                this.doc.fontSize(18)
                  .font('Helvetica-Bold')
                  .fillColor(color.border)
                  .text(`#${index + 1}`, 60, cardY + 10);

                // Nombre del paquete
                this.doc.fontSize(14)
                  .font('Helvetica-Bold')
                  .fillColor(this.colors.secondary)
                  .text(pkg.name, 90, cardY + 8);

                // Versi√≥n
                this.doc.fontSize(10)
                  .font('Helvetica')
                  .fillColor(this.colors.secondary)
                  .text(`v${pkg.currentVersion}`, 90, cardY + 25);

                // Severidad
                this.doc.fontSize(12)
                  .font('Helvetica-Bold')
                  .fillColor(color.text)
                  .text(pkg.severity.toUpperCase(), 300, cardY + 10);

                // Contador de vulnerabilidades
                this.doc.fontSize(16)
                  .font('Helvetica-Bold')
                  .fillColor(color.border)
                  .text(`${pkg.vulnerabilityCount}`, 450, cardY + 8);

                this.doc.fontSize(10)
                  .font('Helvetica')
                  .fillColor(this.colors.secondary)
                  .text('vulnerabilidades', 420, cardY + 30);

                // Recomendaci√≥n
                this.doc.fontSize(10)
                  .font('Helvetica')
                  .fillColor(this.colors.secondary)
                  .text(pkg.recommendation, 90, cardY + 40, { width: 300 });

                this.doc.y = cardY + 75;
              });

              this.doc.